---
title: for
description: 'Windows コマンド」のトピック * * *- '
ms.custom: na
ms.prod: windows-server-threshold
ms.reviewer: na
ms.suite: na
ms.technology: manage-windows-commands
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 13a44bc3497b44d60bd4d351e389d493a50f1269
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2019
ms.locfileid: "59869463"
---
# <a name="for"></a>for



一連のファイルに各ファイルの指定したコマンドを実行します。

このコマンドを使用する方法の例については、[例](#BKMK_examples)を参照してください。

## <a name="syntax"></a>構文

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

## <a name="parameters"></a>パラメーター

|パラメーター|説明|
|---------|-----------|
|{%%\|%}\<変数 >|必須。 置き換え可能パラメーターを表します。 1 つのパーセント記号を使用して (**%**) 実行するために、**の**コマンド プロンプトでコマンド。 二重のパーセント記号を使用して (**%%**) 実行するために、**の**バッチ ファイル コマンド。 変数は、大文字小文字を区別、およびなど、アルファベット順の値で表現する必要があります **%A**、 **%B**、または **%C**します。|
|(\<設定 >)|必須。 1 つまたは複数のファイル、ディレクトリ、またはテキスト文字列、または、コマンドを実行する対象の値の範囲を指定します。 かっこが必要です。|
|\<コマンド >|必須。 各ファイル、ディレクトリ、またはテキスト文字列、またはに含まれる値の範囲を実行するコマンドを指定*設定*します。|
|\<CommandLineOptions >|指定されたコマンドに使用する任意のコマンド ライン オプションを指定します。|
|/?|コマンド プロンプトにヘルプを表示します。|

## <a name="remarks"></a>注釈

-   使用して**の**

    使用することができます、**の**バッチ ファイルまたはコマンド プロンプトから直接コマンド。
-   バッチのパラメーターを使用します。

    次の属性を適用する、**の**コマンド。  
    -   **の**のコマンドは **% * * * 変数*または **%% * * * 変数*指定したコマンドがすべてのファイルを処理するまでは、指定されたセット内の各テキスト文字列に置き換えます。
    -   変数名では大文字小文字を区別、グローバル、および一度にアクティブにできる 52 よりもなくなります。
    -   バッチのパラメーターと混同しないようにする **%0**を通じて **%9**、任意の文字を使用する*変数*0 ~ 9 の数字を除きます。 バッチ ファイル、1 つの文字などの単純な **%%1**は機能します。
    -   複数の値を使用する*変数*置き換え可能の異なる変数を区別するために複雑なバッチ ファイルでします。
-   ファイルのグループを指定します。

    *設定*パラメーターは、ファイルの 1 つのグループまたはファイルのいくつかのグループを表すことができます。 ワイルドカード文字を使用することができます (**&#42;** と **?**) ファイルを指定する設定。 以下は、有効なファイル セットです。  
    ```
    (*.doc) 
    (*.doc *.txt *.me)
    (jan*.doc jan*.rpt feb*.doc feb*.rpt)
    (ar??1991.* ap??1991.*)
    ```  
    使用すると、**の**コマンドの最初の値*設定*置換 **% * * * 変数*または **%% * * * 変数*とし、指定しました。コマンドは、この値を処理します。 これは、問題が引き続きまでに対応するすべてのファイル (またはファイルのグループ)、*設定*値が処理されます。
-   使用して、**で**と**は**キーワード

    **** と**は**パラメーターではありませんでそれらを使用する必要があります**の**します。 これらのキーワードのいずれかを省略した場合、エラー メッセージが表示されます。
-   追加フォームを使用して**の**

    (既定では)、つまりコマンド拡張機能が有効な場合、次の形式の**の**はサポートされています。  
    -   ディレクトリのみ

        場合*設定*ワイルドカード文字が含まれています (**&#42;** または **?**)、指定した*コマンド*(セットではなくディレクトリごとに実行します一致する指定されたディレクトリ内のファイル) の*設定*します。

        構文は次のとおりです。  
        ```
        for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
        ```  
    -   ［再帰］

        ルートにディレクトリ ツリーをウォーク*ドライブ*:*パス*を実行し、**の**ツリーの各ディレクトリ内のステートメント。 後にディレクトリが指定されていない場合 **/r**、現在のディレクトリがルート ディレクトリとして使用されます。 場合*設定*単一のピリオド (.) だけは、ディレクトリ ツリーのみを列挙します。

        構文は次のとおりです。  
        ```
        for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        ```  
    -   値の範囲を反復処理します。

        反復変数を使用して、開始値を設定する (*開始*#) と値セットの終了値を超える値までの範囲を手順 (*エンド*#)。 **/l**比較することによって、反復的な実行*開始*# を*エンド*# です。 場合*開始*# はより小さい*エンド*# コマンドが実行されます。 反復変数値を超えると*エンド*#、コマンド シェルは、ループを終了します。 負の値を使用することもできます。*手順*# をステップ実行範囲の値が減少します。 たとえば、(1,1,5) 1 2 3 4 5 シーケンスを生成と (5、-1, 1) 5 4 3 2 1 のシーケンスを生成します。

        構文は次のとおりです。  
        ```
        for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
        ```  
    -   反復処理し、ファイルの解析

        処理コマンドの出力、文字列、およびファイルの内容を解析するファイルを使用します。  反復的な変数を使用して、コンテンツまたは確認する文字列を定義して、さまざまな使用*ParsingKeywords*解析をさらに変更するオプション。  使用して、 *ParsingKeywords*トークンのトークンは、反復的な変数として渡す必要がありますを指定するオプション。 トークンのオプションを指定せずに使用される場合は注意 **/f**最初のトークンだけで検証されます。

        ファイルの解析は、出力、文字列、またはファイルの内容を読み取ると、個々 のテキスト行に分割と 0 個以上のトークンに各行を解析ので構成されます。 **の**ループが反復的な変数の値にトークンを設定して呼び出されます。 既定では、 **/f**各ファイルの各行から、最初の空白区切りトークンを渡します。 空白行はスキップされます。

        構文は次のとおりです。  
        ```
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ("<LiteralString>") do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
        ```  
        *設定*引数を 1 つまたは複数のファイル名を指定します。 各ファイルが開かれ、読み取りの次のファイルを移動する前に処理*設定*します。 既定の解析動作をオーバーライドするには指定*ParsingKeywords*します。 これは、さまざまな解析オプションを指定する 1 つまたは複数のキーワードを含む引用符で囲まれた文字列です。

        使用する場合、 **usebackq**オプションで、次の構文のいずれかを使用します。  
        ```
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ("<Set>") do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
        ```  
        次の表に、解析のキーワードを使用できる*ParsingKeywords*します。  
        |Keyword|説明|
        |-------|-----------|
        |eol=\<c>|改行文字 (1 つだけの文字) の末尾を指定します。|
        |スキップ =\<N >|ファイルの冒頭でスキップする行数を指定します。|
        |delims=\<xxx>|区切り記号セットを指定します。 これには、スペースやタブの既定の区切り記号のセットが置き換えられます。|
        |tokens=\<X,Y,M–N>|渡される各行からトークンを指定、**の**各イテレーションでループします。 その結果、追加の変数名が割り当てられます。 *M*–*N*から範囲を指定します、 *M*番目から、 *N*番目のトークン。 場合の最後の文字、**トークン =** 文字列は、アスタリスク (**&#42;**)、追加の変数を割り当て、および最後のトークンが解析された後の行の残りのテキストを受信します。|
        |usebackq|指定しますコマンドとしてバック引用符で囲まれた文字列を実行する単一引用符で囲まれた文字列を使用して、文字列リテラルとしてに対して、または時間の長いファイル名にスペースが含まれるファイル名を許可する*\<設定\>* をで囲む各。二重引用符です。|
    -   変数の代入

        次の表は、省略可能な構文を示します (任意の変数**は**)。  
        |修飾子を持つ変数|説明|
        |----------------------|-----------|
        |% ~ は|展開 **%I**囲む引用符をすべて削除します ("")。|
        |% ~ fI|展開 **%I**の完全修飾パス名にします。|
        |% ~ dI|展開 **%I**ドライブ文字のみにします。|
        |% ~ pI|展開 **%I**のみのパスにします。|
        |% ~ nI|展開 **%I**のみのファイル名にします。|
        |% ~ xI|展開 **%I**のみとファイル名拡張子。|
        |% ~ sI|短い名前のみを格納するパスを展開します。|
        |% ~ aI|展開 **%I**ファイルのファイル属性。|
        |% ~ tI|展開 **%I**ファイルの日時にします。|
        |% ~ zI|展開 **%I**ファイルのサイズにします。|
        |% ~ $PATH: しました|PATH 環境変数で設定されているディレクトリを検索し、展開 **%I**見つかった最初のディレクトリの完全修飾名にします。 環境変数の名前が定義されていないか、検索によって、ファイルが見つからない、この変数は空の文字列に展開されます。|

        次の表では、複合の結果を得るために使用できる修飾子の組み合わせを示します。  
        |結合された修飾子を持つ変数|説明|
        |--------------------------------|-----------|
        |% ~ dpI|展開 **%I**先ドライブ文字とパスのみです。|
        |% ~ nxI|展開 **%I**ファイル名と拡張子のみにします。|
        |% ~ fsI|展開 **%I**短い名前のみで完全なパス名にします。|
        |%~dp$PATH:I|PATH 環境変数で指定されているディレクトリを検索 **%I**ドライブ文字と最初のパスに展開します。|
        |% ~ ftzaI|展開 **%I**のような出力行に**dir**します。|

        上記の例で置き換えることができます **%I**で他の有効な値とパス。 有効な**の**変数名の終了、 **%~** 構文。

        変数名の大文字を使用して、 **%I**コードを読みやすくして、修飾子は、小文字は区別されませんと混同しないようにすることができます。
-   文字列の解析

    使用することができます、 **/f の**解析即時の文字列でのロジックをラップすることによって*\<LiteralString\>* でいずれか: 二重引用符 (*せず*"usebackq") または単一引用符で囲みます (*で*"usebackq")--の例では、("MyString") または ('MyString')。 *\<LiteralString\>* ファイルからの入力の単一行として扱われます。 解析するときに*\<LiteralString\>* コマンド記号、二重引用符で (など **\\ \& \| \> \< \^**) は通常の文字として扱われます。
-   出力の解析

    使用することができます、 **/f の**バック クォートを配置することで、コマンドの出力を解析するコマンド*\<コマンド\>* かっこの間。 Cmd.exe の子に渡されるコマンドラインとして扱われます。 出力がメモリにキャプチャされ、ファイルが解析。

## <a name="BKMK_examples"></a>例

使用する**の**バッチ ファイルで、次の構文を使用します。
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
置き換え可能な変数を使用して、拡張子 .doc や .txt を持つ現在のディレクトリ内のすべてのファイルの内容を表示する **%f**種類。
```
for %f in (*.doc *.txt) do type %f 
```
前の例では各ファイルを現在のディレクトリに .doc や .txt 拡張子を持つで置き換えられます、 **%f**変数まで、すべてのファイルの内容が表示されます。 このコマンドをバッチ ファイルを使用する置換出現するすべての **%f**で **%%1**します。 それ以外の場合、変数は無視され、エラー メッセージが表示されます。

ファイルを解析するには、行、型のコメントは無視されます。
```
for /f "eol=; tokens=2,3* delims=," %i in (myfile.txt) do @echo %i %j %k
```
このコマンドは、Myfile.txt 内の各行を解析します。 メソッドは、セミコロンで始まる行を無視しを各行から 2 番目と 3 番目のトークンを渡します、**の**本文 (トークンは空白またはコンマで区切られます)。 本体、**の**ステートメント参照 **%i** 、2 つ目のトークンを取得する **%j** 3 番目のトークンを取得し、 **%k**残りのすべてを取得するにはトークンです。 指定したファイル名にスペースが含まれている場合は、(たとえば、「ファイル名」) のテキストを囲む引用符を使用します。 使用する必要があります引用符を使用する**usebackq**します。 それ以外の場合、引用符は、解析するリテラル文字列を定義するとして解釈されます。

**%i**で明示的に宣言されて、**の**ステートメント。 **%j**と **%k**を使用して暗黙的に宣言**トークン =** します。 使用することができます**トークン =** を最大 26 個のトークンを指定して、文字"z"または"Z にします"より高い変数を宣言する試行は行われませんを指定。

次の例では、現在の環境で環境変数の名前を列挙します。 配置することで、コマンドの出力を解析する*設定*かっこの間に入力します。
```
for /f "usebackq delims==" %i in ('set') do @echo %i 
```

#### <a name="additional-references"></a>その他の参照情報

[コマンドライン構文キー](command-line-syntax-key.md)
